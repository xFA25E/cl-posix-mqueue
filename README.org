#+TITLE: Cl-Posix-Mqueue

Common Lisp bindings to POSIX message queues.  Contributions and questions are
welcome.

POSIX message queue is an IPC (Inter-Process Communication) method that is easy
to use and quick to setup.

* Examples
** Create a queue, send and receive a message, unlink queue.
   #+begin_src lisp
     (with-open-queue (mq "/myqueue" :open-flags '(:read-write :create)
                                     :max-messages 5 :message-size 10)
       ;; Messages are ordered based on priority.  High priority messages are placed
       ;; at the beginning.
       (send-string mq "hello" 4)            ; 4 is priority
       (multiple-value-bind (msg-string priority) (receive-string mq)
         (when (and (string= "hello" msg-string) (= 4 priority))
           (print "It works!"))))
     (unlink "/myqueue")
   #+end_src
** Open existing queue and wait for a message for 1 second
   #+begin_src lisp
     (with-open-queue (mq "/myqueue" :open-flags '(:read-only))
       (multiple-value-bind (msg priority)
           ;; Timestamps are absolute
           (timed-receive-string mq (local-time:timestamp+ (local-time:now) 1 :sec))
         (when (eq :connection-timed-out msg)
           (print "Timed out!"))))
     (unlink "/myqueue")
   #+end_src
** Create a queue, try to receive a message and return immediately because a call would block
   #+begin_src lisp
     (with-open-queue (mq "/myqueue" :open-flags '(:read-only :create :non-blocking))
       (multiple-value-bind (msg priority) (receive-string mq)
         (when (eq :try-again msg)
           (print "Would block!"))))
     (unlink "/myqueue")
   #+end_src
* Usage
  This library uses [[https://common-lisp.net/project/local-time/][local-time]] library for timestamps.  All of the following symbols are
  documented in details through the internal common lisp documentation system.

  Available symbols:
  - ~mq:*retry-on-interrupt-p*~ :: Is an option that let's you specify whether or not the
    send/receive operation should be retried on inturrupt.
  - ~mq:attributes~ :: Get attributes of a queue.
  - ~mq:close~ :: Close connection to a queue.
  - ~mq:make~ :: Make connection to a queue.
  - ~mq:non-blocking~ :: A setf'able-only function that changes a /non-blocking/
    attribute of a queue.
  - ~mq:receive~ :: Receive message from a queue in a form of ~(array (unsigned-byte 8))~.
  - ~mq:receive-displaced~ :: Like ~mq:receive~ but returns a displaced array from an
    internal buffer.
  - ~mq:receive-string~ :: Receive message from a queue and try to convert it to a
    string.
  - ~mq:send~ :: Send a message to queue in a form of ~(array (unsigned-byte 8))~.
  - ~mq:send-string~ :: Send string to a queue.
  - ~mq:timed-receive~ :: Like ~mq:receive~, but allows specifying an absolute timestamp
    for waiting if the queue is empty.
  - ~mq:timed-receive-displaced~ :: See ~mq:timed-receive~ and ~mq:receive-displaced~.
  - ~mq:timed-receive-string~ :: See ~mq:timed-receive~ and ~mq:receive-string~.
  - ~mq:timed-send~ :: Like ~mq:send~, but allows specifying an absolute timestamp for
    waiting if the queue is full.
  - ~mq:timed-send-string~ :: See ~mq:timed-send~ and ~mq:send-string~.
  - ~mq:unlink~ :: Unlink a queue.
  - ~mq:with-queue~ :: Macro that facilitates queue closing routine.
  - ~mq.attr:current-messages~ :: Get the number of the messages currently available on a
    queue from attributes.
  - ~mq.attr:max-messages~ :: Get the maximum number of possible messages on a queue from
    attributes.
  - ~mq.attr:message-size~ :: Get the maximum message size possible on a queue from
    attributes.
  - ~mq.attr:non-blocking-p~ :: Get the /non-blocking/ attribute of a queue from
    attributes.
  - ~mq.cond:kind~ :: Get a condition /kind/.
  - ~mq.cond:access-denied~ :: Permission denied condition.
  - ~mq.cond:bad-file-descriptor~ :: Bad file descriptor condition.
  - ~mq.cond:file-exists~ :: File exists condition.
  - ~mq.cond:file-table-overflow~ :: Too many open files in system condition.
  - ~mq.cond:interrupted-system-call~ :: Interrupted system call condition.
  - ~mq.cond:invalid-argument~ :: Invalid argument condition.
  - ~mq.cond:message-too-long~ :: Message too long condition.
  - ~mq.cond:name-too-long~ :: File name too long condition.
  - ~mq.cond:no-file-or-directory~ :: No such file or directory condition.
  - ~mq.cond:no-space-left-on-device~ :: No space left on device condition.
  - ~mq.cond:out-of-memory~ :: Cannot allocate memory condition.
  - ~mq.cond:too-many-open-files~ :: Too many open files condition.

* Todo
** Features
*** mq_notify
** Polish
*** [#A] use some kind of doc generator or put in readme
*** [#B] try to make environment with sbcl and custom userinit
*** [#C] also test on other lisps
*** publish to quicklisp and awesome-cl
